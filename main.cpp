// Программа "Hello, World!" на C++ это базовое обьяснение, которое не вводит в детали того, как это работает.

/*
    Директива препроцессора #include <iostream>
    -------------------------------------------
    Директива #include указывает препроцессору на необходимость включить в исходный код содержимое заголовочного файла.
    Заголовочный файл <iostream> — это часть стандартной библиотеки C++, которая содержит декларации классов и функций
    для работы с потоками ввода и вывода (например, std::cout для вывода данных на консоль).

    Как это работает:
    1. Препроцессор: Прежде чем компилятор увидит ваш код, препроцессор обрабатывает все директивы #include.
       Он буквально находит файл iostream и вставляет его содержимое в ваше место, где находится директива #include.
    2. Содержимое iostream: Этот файл содержит объявления всех необходимых объектов для работы с потоками, таких как std::cout (поток вывода),
       std::cin (поток ввода), std::cerr (поток ошибок) и множество вспомогательных функций.
    3. Объект std::cout: Внутри iostream вы найдете объявление глобального объекта std::cout, который представляет стандартный вывод в C++.
       std::cout — это объект класса std::ostream, который наследуется от базового класса для всех потоков.

    Под капотом (внутри iostream):
    ------------------------------
    Когда ваш компилятор подключает файл iostream, вы получаете доступ к глобальным объектам и функциям,
    которые используют стандартные механизмы потоков для работы с консолью (или другими устройствами ввода-вывода).
    Эти механизмы реализуются в виде файловых дескрипторов на уровне операционной системы, что позволяет вам взаимодействовать
    с устройствами на низком уровне. То есть std::cout фактически взаимодействует с файловым дескриптором, который привязан к консоли.

    Как работает поток вывода (std::cout):
    --------------------------------------
    Потоки в C++ — это концепция, которая абстрагирует работу с устройствами ввода и вывода.
    Например, поток вывода (std::cout) позволяет программе передавать данные на экран через консоль.
    Поток — это последовательность данных, которая направляется на одно или несколько устройств.

    Буферизация:
    ------------
    Когда вы что-то выводите через std::cout, данные сначала попадают во внутренний буфер.
    Буферизация — это процесс накопления данных в памяти перед их отправкой на устройство (в данном случае — на консоль).
    Буферизация делает ввод-вывод более эффективным, так как уменьшает количество вызовов к операционной системе для вывода
    каждого символа по отдельности. После накопления определённого количества данных происходит сброс буфера (flush),
    который отправляет содержимое буфера на устройство вывода (экран).

    Системный вызов write():
    ------------------------
    Когда происходит сброс буфера, поток вывода вызывает системный вызов write(), который передает данные из программы в ОС.
    В UNIX-подобных системах этот вызов записывает данные в файловый дескриптор stdout, связанный с консолью.
    Таким образом, каждый символ, переданный в std::cout, фактически записывается в файловый дескриптор,
    а затем ОС отображает эти данные на экране.

    Внутреннее устройство iostream:
    -------------------------------
    iostream использует объекты потоков (streams), чтобы представить устройства ввода-вывода.
    Внутри iostream существуют классы, которые управляют потоками через перегрузку операторов,
    таких как оператор <<, который используется для вывода данных.
*/
#include <iostream>

/*
    Пролог функции main():
        ---------------------
        Компилятор создает специальный код в начале функции main(), называемый прологом.
        Этот код выполняет следующие действия:
        
        1. Сохраняет текущие значения регистров процессора (такие как регистр инструкций, регистр фрейма стека) на стеке.
        2. Инициализирует стековую рамку для функции main() — это необходимо для того, чтобы выделить место для локальных переменных.
        3. Сохраняет указатель на предыдущий фрейм стека, чтобы при выходе из функции можно было вернуться назад.
        
        Например, на архитектуре x86 (32-битной):
        ----------------------------------------
        Компилятор может сгенерировать следующие инструкции:
        push ebp         // Сохраняем базовый указатель предыдущей стековой рамки
        mov ebp, esp     // Устанавливаем новый базовый указатель для текущей функции
        sub esp, X       // Выделяем X байт памяти для локальных переменных
        
        Эти инструкции управляют организацией стека в памяти и подготовкой процессора к выполнению кода функции.
*/
int main() { 

    /*
        std::cout << "Hello, World!"
        --------------------------------
        std::cout — это объект класса std::ostream, который используется для вывода данных в стандартный поток вывода (обычно консоль).
        Оператор << — это оператор перегрузки, который позволяет передавать данные в поток вывода.

        Поток вывода (std::cout):
        -------------------------
        std::cout использует файловый дескриптор для взаимодействия с консолью. В UNIX-подобных системах это файловый дескриптор stdout.
        std::cout управляет этим дескриптором и взаимодействует с ним через системные вызовы.

        Оператор << (оператор "вставки"):
        ---------------------------------
        В C++ оператор << перегружен для работы с разными типами данных. Когда вы пишете std::cout << "Hello, World!",
        фактически происходит вызов функции, которая передает строку "Hello, World!" в поток std::cout.

        Важно: Оператор << — это перегруженная функция, которая принимает данные и передаёт их в поток.
        Для строковых данных оператор << вызывает специальную версию функции для работы с C-style строками.

        Буферизация и сброс (flush):
        ----------------------------
        std::cout использует внутренний буфер для накопления данных перед их выводом на экран.
        Это значит, что строка "Hello, World!" может быть не выведена на экран немедленно. Только когда
        буфер заполнится или произойдет принудительный сброс (flush), данные будут отправлены на устройство вывода (консоль).

        Системные вызовы write() и stdout:
        ----------------------------------
        Когда буфер заполняется или выполняется вызов std::endl, данные отправляются на консоль.
        В этот момент вызывается системный вызов write(), который передает данные операционной системе.
        Операционная система уже передает данные на соответствующее устройство — в нашем случае это консоль.
        Таким образом, строка "Hello, World!" попадает на экран.

        Как работает вывод строки:
        --------------------------
        1. Строка "Hello, World!" передаётся в поток std::cout.
        2. Поток std::cout накапливает строку в своём буфере.
        3. Когда происходит сброс буфера (или по завершению программы), содержимое буфера передаётся в операционную систему.
        4. Операционная система использует системный вызов write() для записи данных в файловый дескриптор stdout.
        5. Данные из stdout передаются терминалу (консоли), которая отображает их на экране как текст.

        std::endl:
        ----------
        std::endl выполняет две задачи:
        1. Перевод строки — добавляет символ новой строки ('\n'), который указывает консоли начать вывод с новой строки.
        2. Сброс буфера (flush) — после добавления новой строки std::endl принудительно сбрасывает содержимое буфера в поток вывода.

        Сброс буфера — это важный процесс, так как данные не будут немедленно выведены на экран,
        пока не произойдёт явный сброс (flush) или программа не завершится.

        Как это работает на уровне инструкций процессора:
        -------------------------------------------------
        Компилятор сгенерирует код для загрузки адреса строки "Hello, World!" в регистры процессора. Например, на архитектуре x86:
        
        mov eax, offset HelloWorldString  // Загружаем адрес строки "Hello, World!" в регистр eax
        call std::ostream::operator<<     // Вызываем оператор << для объекта std::cout
        
        Когда вызывается функция, процессор использует стек для передачи параметров (например, адрес строки) и управления вызовами функций.
        Процессор выполняет инструкцию `call`, которая сохраняет адрес возврата в стек, а затем переходит к коду оператора <<.
        
        Работа с буфером и системные вызовы:
        ------------------------------------
        std::cout использует буферизацию для более эффективного вывода данных. Когда буфер заполнен или вызван std::endl, происходит системный вызов.
        Системный вызов — это особая инструкция, которая переводит процессор из пользовательского режима в режим ядра (привилегированный режим).
        Например, в UNIX-подобных системах используется системный вызов write() для записи данных в файловый дескриптор консоли (stdout).
        
        Вызов системной функции:
        ------------------------
        Процессор выполняет переход в режим ядра и вызывает функцию write() с указанием адреса буфера и количества байт для записи.
        Ядро операционной системы обрабатывает запрос и отправляет данные в драйвер терминала, который отображает их на экране.
    */
    std::cout << "Hello, World!" << std::endl;

    /*
        Завершение программы:
        ---------------------
        return 0;
        Функция main() возвращает целое значение. В данном случае мы возвращаем 0,
        что по соглашению означает успешное завершение программы.

        Операционная система:
        ---------------------
        Когда программа завершается, операционная система принимает возвращённое значение main() и интерпретирует его как код завершения.
        Код 0 указывает на успешное завершение. Любое ненулевое значение может указывать на ошибку.

        Что происходит при завершении программы:
        ----------------------------------------
        1. Программа завершает выполнение всех инструкций в main().
        2. Все ресурсы, выделенные под программу (память, файловые дескрипторы и т.д.), освобождаются операционной системой.
        3. Операционная система записывает код завершения программы (0) и завершает процесс.

        После выполнения всех инструкций в main(), компилятор генерирует код эпилога, который завершает выполнение функции:
        
        1. Восстанавливаются значения регистров, сохраненные в начале функции.
        2. Указатель стека восстанавливается в исходное состояние.
        3. Процессор выполняет инструкцию возврата (ret), которая извлекает адрес возврата из стека и передает управление операционной системе.
        
        Пример на архитектуре x86:
        --------------------------
        mov esp, ebp   // Восстанавливаем указатель стека
        pop ebp        // Восстанавливаем базовый указатель фрейма
        ret            // Возвращаем управление операционной системе
        
        После выполнения этих инструкций программа завершает своё выполнение, и операционная система освобождает все ресурсы, которые были выделены для неё.
        return 0; возвращает код успешного завершения программы, который ОС может использовать для определения того, была ли программа завершена корректно.
    */
    return 0
